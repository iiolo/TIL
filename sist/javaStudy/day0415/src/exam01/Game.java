package exam01;

import java.awt.Graphics;
import java.awt.Image;
import java.awt.event.KeyEvent;
import java.awt.event.KeyListener;
import java.awt.image.BufferedImage;
import java.io.File;
import java.util.ArrayList;
import java.util.Random;

import javax.imageio.ImageIO;
import javax.sound.sampled.AudioSystem;
import javax.sound.sampled.Clip;
import javax.swing.JFrame;
import javax.swing.JPanel;
import javax.xml.crypto.dsig.keyinfo.KeyValue;

//적,플레이어,미사일이 공통으로 가져야할 부모클래스를 만들어요
class GraphicObject{
	
	//그림파일을 참조할 변수를 선언합니다.
	BufferedImage img = null;
	
	//그림을 출력할 위치 변수를 선언합니다.
	int x=0, y=0;
	
	//생성시에 그림파일명을 전달받아요
	public GraphicObject(String name) {
		try {		//그림파일을 읽어 들이때에 예외가 발생하기 때문에 예외처리를 해 줍니다.
			img = ImageIO.read(new File(name));
		}catch (Exception e) {
			//예외가 발생하면 예외메세지를 출력합니다.
			System.out.println("예외발생:"+e.getMessage());
			
			//프로그램을 종료시킵니다.
			System.exit(0);
		}
	}
	
	//그래픽의 위치를 변경하기 위한 메소드를 정의합니다.
	//body를 구체화 하지 않아서 자식클래스들이 자신에게 맞도록 오버라이딩 하도록 합니다.
	public void update() {}
	
	//변경된 위치에 그래픽을 그려주기 위한 메소드입니다.	
	public void draw(Graphics g) {	
		g.drawImage(img, x, y, null);
	}
	
	//키보드 이벤트를 처리하기 위한 메소드입니다.
	//body를 구체화 하지 않아서 자식클래스들이 자신에게 맞도록 오버라이딩 하도록 합니다.
	public void keyPressed(KeyEvent event) {}
	
}

//GraphicObject를 확장한 미사일 클래스를 만들어요
class Missile extends GraphicObject{
	
	//미사일을 그려줄지 말지를 위한 상태변수
	boolean launched = false;
	
	//생성시에 미사일의 그림파일이름은 전달받아요
	public Missile(String name) {
		
		//그림파일이름을 부모생성에게 전달합니다.
		super(name);
		
		//미사일의 y좌표를 -200으로 설정합니다.
		y=-200;
	}

	//미사일의 위치를 변경하기 위하여 부모의 update메소드를 오버라이딩 합니다.	
	public void update() {
		
		//현재 미사일이 발사 된상태라면(그려줘야 하는 상태라면)
		//미사일이 위로 진행하도록 1만큼 계속하여 감소시킵니다.
		if(launched == true) {
			y=y-50;
		}
		
		//만약 미사일이 위치가 감소하여 화면의 영역에서 벗어났다면
		//미사일을 화면에 그릴필요가 없으므로 launched에 false를 저장합니다.
		if(y < -100) {
			launched = false;
		}
	}
	
	//키보드가 눌러지는 이벤트 처리를 위한 메소드를 만들어요
	//키보드이벤트와 미사일의 출발점 x,y좌표를 매개변수로 전달받아
	public void keyPressed(KeyEvent event, int x, int y) {
		
		//눌러진키가 스페이스바 인지 판별합니다.
		if(event.getKeyCode() == KeyEvent.VK_SPACE) {
			
			//미사일을 발사시키기 위하여 launched에 true를 설정합니다.
			launched = true;
			
			//미사일의 출발위치를 설정합니다.
			this.x = x;
			this.y = y;
			
			//미사일이 발사 되었을때 소리도 나게 합니다.
			
			//소리파일 객체를 생성합니다.
			File file = new File("LASER.WAV");
			
			try {
				//오디오 파일을 읽어오기 위한 준비를 합니다.
				Clip clip = AudioSystem.getClip();
				
				//오디오 파일을 읽어옵니다.
				clip.open(AudioSystem.getAudioInputStream(file));
				
				//오디오파일을 재생합니다.
				clip.start();
				
			}catch (Exception e) {
				System.out.println("예외발생:"+e.getMessage());
			}
		}
	}
	
}


//적을 위한 클래스를 만들어요
class Enermy extends GraphicObject{
	
	//적의 x축 이동간격을 정해요
//	int dx = -10;

	//적의 이동경로를 난수로 만들어요
	int dx;
	int dy;
	
	
	//생성시에 적의 그림파일명을 전달받아요
	public Enermy(String name) {
		
		//부모의 생성자에게 그림파일명을 전달합니다.
		super(name);
		
		System.out.println("적이 생성됨");
		
		Random r = new Random();
		
		//적의 위치를 설정합니다. 맨첨음 적의 위치를 난수를 만들어서 설정합니다. 
		x = r.nextInt(500);
		y = r.nextInt(300);
		
		//적의 이동하는 값을 난수를 만들어요
		dx = r.nextInt() % 30;     // 만약에 양수라면 0~29  
		dy = r.nextInt() % 30;
		
		//이동하는 거리의 최소값을 10이상으로 만들고 싶어요
		if(dx >= 0) {
			dx += 10;   //만약에 양수라면 10~39
		}else {
			dx -= 10;	
		}
		
		if(dy >= 0) {
			dy += 10;
		}else {
			dy -= 10;
		}
		
	}
	
	//적의 위치를 변경시키기 위한 update메소드를 오버라이딩 합니다.
	public void update() {
		
		//x축으로만 이동시키기 위하여 
		//x에 이동거리인 dx를 누적합니다.
		x += dx;
		
		//y축으로 이동시키기 위하여
		//y에 이동거리인 dy를 누적합니다.
		y += dy;
		
		//x축의 범위를 넘었다면 반대방향으로 이동하도록 합니다.
		if(x < 0 || x >= 500) {
			dx = dx * -1;
		}
		
		//y축의 이동범위를 넘었다면 반대방향으로 이동하도록 합니다.
		if(y < 0 || y >= 300) {
			dy = dx * -1;
		}
		
	}
	
	//적이 미사일에 맞았으면 사라지게 하는 메소드를 정의
	//이메소드는 일을 하기 위하여 매개변수를 무엇을 전달받아야 할까요?  ==> 미사일 좌표
	//이메소드는 어디에서 호출하면 될까요?
	public void crush(Missile missile) {
		//적의 가로,세로길을 40이라고 보고 
		//미사일의 x,y좌표가 그 범위안에 있는지 판별합니다.
		if(missile.x >= x && missile.x <= x + 40&& missile.y >= y && missile.y <= y + 40) {
			
			//y좌표값을 음수를 주어서 사라지게 합니다.
			y=-1000;
		}
	}
	
}


//플레이어를 위한 클래스를 만들어요
class SpaceShip extends GraphicObject{
	
	//생성시에 그림파일명을 전달받아요
	public SpaceShip(String name) {
		
		//부모의 생성자에게 그림파일명을 전달합니다.
		super(name);
		
		//플레이어의 위치를 설정합니다.
		x = 150;
		y = 350;
	}
	
	//키보드 이벤트처리를 위한 메소드를 정의합니다.
	public void keyPressed(KeyEvent event) {
		
		//왼쪽방향키를 눌렀다면 x의 값을 감소시켜 플레이어 위치를 왼쪽으로 이동시키도록 합니다.
		if(event.getKeyCode() == KeyEvent.VK_LEFT) {
			x = x - 10;
		}
		
		//오른쪽방향키를 눌렀다면 x의 값을 증가시켜 플레이어 위치를 오른쪽으로 이동시키도록 합니다.
		if(event.getKeyCode() == KeyEvent.VK_RIGHT) {
			x = x + 10;
		}
		
		//위쪽방향키를 눌렀다면 y의 값을 감소시켜 플레이어 위치를 위쪽으로 이동시키도록 합니다.
		if(event.getKeyCode() == KeyEvent.VK_UP) {
			y = y - 10;
		}
		
		//아래쪽방향키를 눌렀다면 y의 값을 증가시켜 플레이어 위치를 아래쪽으로 이동시키도록 합니다.
		if(event.getKeyCode() == KeyEvent.VK_DOWN) {
			y = y + 10;
		}
		
		
	}
}


//적,플레이어,미사일을 그래픽을 표현하기 위한 패널클래스를 만들어요
//키보드이벤트 처리를위하여 KeyListener인터페이스를 구현하도록 합니다.
class MyPanel extends JPanel implements KeyListener{
	
	//게임의 구성요소인 적, 플레이어, 미사일 객체를 맴버변수로 선언합니다.
	//Enermy enermy;
	//적을 여러개 만들어요
	ArrayList<Enermy> enermyList;
	SpaceShip spaceShip;
	Missile missile;
	
	//생성자에서 키보드이벤트를 등록하고 
	//각각의 적,플레이어,미사일 객체를 생성합니다.
	public MyPanel() {
		
		
		
		
		//키보드 이벤트를 등록합니다.
		addKeyListener(this);
		
		//컨테이너 역할인 패널에 키보드 이벤트를 등록하기 위하여 다음의 메소드를 호출합니다.
		requestFocus();
		setFocusable(true);
		
		//적을 위한 객체를 생성합니다.
		//enermy = new Enermy("enemy.png");
		//여러개의 적을 만들기 위하여 리스트를 생성합니다.
		enermyList = new ArrayList<Enermy>();
		enermyList.add(new Enermy("enemy.png"));
		enermyList.add(new Enermy("enemy.png"));
		enermyList.add(new Enermy("enemy.png"));
		enermyList.add(new Enermy("enemy.png"));
		enermyList.add(new Enermy("enemy.png"));
		
		//플레이어를 위한 객체를 생성합니다.
		spaceShip = new SpaceShip("player.png");
		
		//미사일을 위한 객체를 생성합니다.
		missile = new Missile("misile.png");
		
		//적,플레이어,미사일이 
		//각자 서로 방해받지 않고 그래픽을 표현하도록 쓰레드클래스를 만들어요.
		//그리고 이클래스는 다른곳에서는 사용될 일이 없고
		//여기 패널에서만 필요합니다. 이때에 클래스를 클래스안에 만들 수 있어요 ==> inner 클래스
		class MyThread extends Thread{

			//run을 오버라이딩 하여 쓰레드가 해야할 일을 써 줍니다.
			public void run() {
					
				//계속반복하여 적,플레이어,미사일의 위치를 변경하여 다시 그리도록 합니다.
				while(true) {
					spaceShip.update();	//플레이어의 위치를 변경합니다.
					missile.update();	//미사일의 위치를 변경합니다.
					
//					enermy.update();	//적의 위치를 변경합니다.
//
//					//적이 미사일에 맞았으면 사라지게 하는 메소드를 호출합니다.
//					enermy.crush(missile);
					
					//여러개의 적이 담긴 리스트의 수 만큼 순회하면서 
					//각각의 적의 위치를 갱신하고 맞았는지 판별하도록 합니다.
					for(Enermy enermy :enermyList) {
						enermy.update();
						enermy.crush(missile);
					}
					
					repaint();			//변경된 위치에 다시 그려줍니다.
					
					try {
						Thread.sleep(100);
					}catch (Exception e) {
					}
				}
			}// end run
			
		}// end Thread
		
		//쓰레드 객체를 생성합니다.
		Thread t = new MyThread();
		
		//쓰레드를 가동합니다.
		t.start();
	}
	
	
	//패널에 그래픽을 표현하기 위하여 paint메소드를 오버라이딩 합니다.
	
	public void paint(Graphics g) {
		
		//부모의 paint를 호출하여 화면을 깨끗이 지웁니다.
		super.paint(g);
		
		//적을 그려줍니다.
		//enermy.draw(g);

		//리스트에 담긴 모든 적을 그려줍니다.
		for(Enermy enermy:enermyList) {
			enermy.draw(g);
		}
		
		//플레이어를 그립니다.
		spaceShip.draw(g);
		
		//미사일을 그립니다.
		missile.draw(g);
		
		
	}




	@Override
	public void keyTyped(KeyEvent e) {
		// TODO Auto-generated method stub
		
	}

	//키보드가 눌러졌을때에 다음의 메소드가 동작합니다.
	public void keyPressed(KeyEvent e) {
		
		//키보드가 눌러지면 플레이어의 위치를 변경하도록 메소드를 호출합니다.
		spaceShip.keyPressed(e);
		
		//키보드가 눌러지면 미사일을 발사시키기 위하여 메소드를 호출합니다.
		//현재 플레이어 위치에서 미사일이 발사 되도록 
		//플레이어의 위치를 같이 전달합니다.
		missile.keyPressed(e, spaceShip.x, spaceShip.y);
	}

	@Override
	public void keyReleased(KeyEvent e) {
		// TODO Auto-generated method stub
		
	}
	
}


//프레임을 위한 클래스를 만들어요
class MyFrame extends JFrame{
	
	//생성자에서 패널을 생성하여 담아요
	public MyFrame() {
		setTitle("My Game");
		add(new MyPanel());
		setSize(500, 500);
		setVisible(true);
		setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);
	}
}

public class Game {
	public static void main(String[] args) {
		new MyFrame();
	}

}
