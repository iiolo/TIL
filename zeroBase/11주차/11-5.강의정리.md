# Typescript 복습

## class 클래스

- ES6 부터 생겨남
- 클래스를 통해서 특정 타입의 객체 생성 가능
- const 변수이름 = new 클래스이름({parameter});
- 클래스로 정의한 인스턴스들을 new 키워드를 통해 변수에 할당할 수 있다
- 타입스크립트의 경우 안에서 타입을 정의해줘야 한다.
- 상속하는 클래스 extends 상속받는 클래스 : 상속하는 클래스의 속성을 상속받는 클래스에서도 사용할 수 있게 됨

### 타입스크립트의 접근 제한자

- es6 안엔 없음,
- private : 선언된 블록 안에서만 접근 가능
- 기본 값은 public
- protected : 다른 곳에 상속이 안됨 -생성자의 매개변수에 접근제한자 같이 작성시 속성 정의와 동시에 전달받은 인자를 해당 속성에 할당하는 작업을 한번에 할 수 있다.

### 인터페이스 구현

- 클래스에서 인터페이스 구현 가능
- class 클래스이름 implements 인터페이스이름 {} 작성 후 클래스 이름에 커서 갖다대고 ctrl+space로 인터페이스 구현 시 자동으로 구현되지 않은 것을 자동으로 만들어줌
- 다중 인터페이스 구현
- 쉼표로 구분
- 이 인터페이스이기도 하고 다른 인터페이스이기도 하다.
- class 클래스이름 implements 인터페이스이름, 인터페이스이름 {}

### abstract

- 완성이 되지 않은 클래스
- abstract class 클래스이름 implements 인터페이스이름{}
- abstract 변수
- abstract 메서드
- 특정 속성이나 메서드에 작성해서 하위타입(상속받는 타입)에서 abstract를 작성한 것을 꼭 가지게 한다.
- 추상 클래스는 인스턴스를 받을 수 없음

### extends

- 클래스 상속 키워드
- 부모로부터 상속받은 자식 클래스 constructor 중괄호 안에는 super(상속받은 것); 작성

## Generics 제네릭

- 타입 변수
- 타입을 파라미터화 할 수 있다
- 다양한 타입을 지원하게끔 해줌
- 타입이 이어짐(동일한 타입이름(ex)T)이 쓰인 곳은 다 똑 같은 타입 )
- 여러 개의 타입을 지정해줄 수도 있다.
- 이름을 원하는대로 작성 가능
- <원하는이름>
- T로 작성하는 것이 관례
- 특정 타입의 하위 타입으로서 타입을 범위를 고정시켜서 사용할 수 있다.

### 클래스 정의

- 여러 타입 지정하고 싶을 시 사용
- 클래스를 정의할 때 T로 제네릭 만들고나서 다른 변수에다가 생성자로 클래스 만들 때 T자리에 온 것이 T 대신에 클래스 인스턴스에서 사용된다

### 인터페이스에서도 사용 가능

- 인터페이스에서도 특정한 값을 유지한체로 인터페이스를 유지할 수 있다.
- 타입 파라미터(T)를 정의하고 그 타입 파라미터를 전달을 하면서 사용할 수 있다.

### 조건부 타입

- 타입파라미터가 해당 인터페이스 일경우
  타입 파라미터 extends 인터페이스이름? true일시 반환 : false일시 반환 으로 작성 가능
- 특정한 행위나 메서드에서 반환되어지는 타입을 타입 파라미터에 전달되는 파라미터에 따라서 다르게 동작하는 것을 만들 수 있다
